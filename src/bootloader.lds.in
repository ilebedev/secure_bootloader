OUTPUT_ARCH( "riscv" )
ENTRY( reset_vector )

SECTIONS
{
  /* Boot ROM contains only the code needed to initialize DRAM,
     and to authenticate the full boot loader.
     This includes the size and expected hash of the boot loader. */

  /* Boot ROM base */
  . = $BOOT_ROM_BASE;

  .text : {
    _start = .;
    *(.text.entry)
    *(.text)
    *(.text)
    *(.rodata)
    *(.got)
    *(.got*)
  }

  ASSERT (( . <= ($BOOT_ROM_BASE + $BOOT_ROM_SIZE) ), "Boot ROM is too large! It won't fit in the ROM.")

  /* Bootloader API state */
  .boot_api_state (NOLOAD) : {
    *(.boot_api_state)
  }

  /* A special HTIF region to communicate with the host */
  . = $HTIF;
  .htif ALIGN(0x1000) (NOLOAD) : {
    *(.htif.fromhost)
    *(.htif.tohost)
  }

  /* Reserve space for secure bootloader stack */
  .stack (NOLOAD) : {
    *(.stack)
  }

  ASSERT (( . <= $BOOT_ADDR), "Segment containing bootloader state, htif, and stacks is too large and extendss past the boot address.")

}
